#define _GNU_SOURCE    // For fexecve
#include <sys/mman.h>  // For memfd_create
#include <unistd.h>    // For read, write, fork, lseek
#include <sys/wait.h>  // For waitpid

//for the bonus part: navigating the history
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

#include <stdlib.h>

#include "nqp_io.h"
#include "nqp_shell.h"

#include <assert.h>
#include <stdint.h>
#include <ctype.h>


//LOGGING RELATED GLOBALS
#define LOG_DISABLED -1
#include <fcntl.h>
int log_fd = LOG_DISABLED;

//COMMAND RELATED CONSTANTS
#define MAX_ARGS 64
#define MAX_ARG_LENGTH 256
#define READ_BUFFER_SIZE 4096  //1024 * 4
#define COMMAND_NOT_FOUND -404
#define COMMAND_EXECUTION_FAILED -403
#define INVALID_ARGUMENTS -300
#define INSUFFICIENT_ARGUMENTS -301
#define REDIRECTION_FAILED -400
#define INVALID_USECASE -204
#define PIPE_READ_END 0
#define PIPE_WRITE_END 0
#define OPERATION_FAILED -500
#define OPERATION_SUCCEED 500

//LOGGING RELATED ROUTINES
void custom_print(const char *message) {
    assert(message != NULL);
    if (!message) return;
    
    // Write to stdout
    printf("%s",message);
    fflush(stdout);
    
    // Write to log file if enabled
    if (log_fd != LOG_DISABLED) {
        write(log_fd, message, strlen(message));
    }
}
void free_logs(){
    if (log_fd != LOG_DISABLED) {
        close(log_fd);
    }
}


//CURRENT DIRECTORY STRUCT
// typedef struct{
//     char path[MAX_LINE_SIZE];
// } Curr_Dir;
Curr_Dir* construct_empty_curr_dir(void){
    //create struct
    Curr_Dir* cwd = (Curr_Dir*)malloc(sizeof(Curr_Dir));
    assert(NULL != cwd);
    if(NULL == cwd) return NULL;

    //initialize with root directory path
    strncpy(cwd->path, "/", MAX_LINE_SIZE);
    assert(is_valid_path(cwd->path));

    //verify it
    assert(is_valid_curr_dir(cwd));
    if(!is_valid_curr_dir(cwd)){    //invalid struct hence free it
        destroy_curr_dir(cwd);
        return NULL;
    }

    //return it
    return cwd;
}
Curr_Dir* construct_curr_dir(const char* path){
    //input validation
    assert(is_valid_path(path));
    if(!is_valid_path(path)) return NULL;

    //create struct
    Curr_Dir* cwd = malloc(sizeof(Curr_Dir));
    strncpy(cwd->path, path, MAX_LINE_SIZE);

    //verify it
    assert(is_valid_curr_dir(cwd));
    if(NULL == cwd) return NULL;
    if(!is_valid_curr_dir(cwd)){    //invalid struct hence free it
        destroy_curr_dir(cwd);
        return NULL;
    }

    //return it
    return cwd;
}
void destroy_curr_dir(Curr_Dir* cwd){
    if(NULL == cwd) return;
    free(cwd);
}
void set_path(Curr_Dir* cwd,const char* path){
    assert(NULL != cwd);
    assert(NULL != path);
    assert(is_valid_path(path));
    if(NULL == cwd || NULL == path) return;
    if(is_valid_curr_dir(cwd)){
        strncpy(cwd->path, path, MAX_LINE_SIZE);
    }
}

//VALIDATORS
bool is_valid_string(const char* str){
    if(NULL == str) return false;
    if(strlen(str) < 1) return false;
    if(strlen(str) > MAX_LINE_SIZE) return false;
    return true;
}
bool is_only_whitespace(const char *str) {
    while (*str) {
        if (!isspace((unsigned char)*str)) {
            return false;
        }
        str++;
    }
    return true;
}
bool is_valid_path(const char* path){
    if(NULL == path) return false;
    if(strlen(path) < 1) return false;
    if(strlen(path) > MAX_LINE_SIZE) return false;
    if('/' != path[0]) return false;
    if(strlen(path) < 1) return false;
    //if('/' != path[strlen(path)-1]) return false;
    //making sure if path do not contain consecutive "/"
    int slash_count = 0;
    for (int i = 0; path[i] != '\0'; i++) {
        if (path[i] == '/') {
            slash_count++;
            if (slash_count >= 2) {
                return false;
            }
        } else {
            slash_count = 0;
        }
    }
    return true;
}
bool is_valid_curr_dir(const Curr_Dir *cwd){
    if(NULL == cwd) return false;
    if(!is_valid_path(cwd->path)) return false;
    return true;
}
void print_string_array(const char *arr[]) {
    for (int i = 0; arr[i] != NULL; i++) {
        printf("%s\n", arr[i]);
        if(NULL == arr[i+1]){
            printf("NULL\n");
        }
        fflush(stdout);
    }
    
}

//builtins
void command_cd(const char* path, Curr_Dir* cwd);
void command_ls(const Curr_Dir* cwd);
void command_pwd(const Curr_Dir *cwd);


//HELPERS
void trim_string(char *str) {
    if(!str) return;
    if(strlen(str) < 1) return;
    int start = 0, end = strlen(str) - 1, i;
    assert(start <= end);
    assert(start >= 0);
    assert(end >= 0);
    // Trim leading whitespace
    while (str[start] == ' ' || str[start] == '\t' || str[start] == '\n') start++;

    // Trim trailing whitespace
    while (end > start && (str[end] == ' ' || str[end] == '\t' || str[end] == '\n')) end--;

    // Shift characters to the beginning of the string
    for (i = 0; i <= end - start; i++) str[i] = str[start + i];

    // Null terminate the string
    str[i] = '\0';
    assert(is_valid_string(str));
}
//COMMAND OBJECT ROUTINES
// typedef struct {
//     int argc;
//     char** argv;
// } Command;
//constructor
Command* command_create(const char* input) {
    assert(input != NULL);
    if (!input) return NULL;

    Command* cmd = (Command*)malloc(sizeof(Command));
    if (!cmd) return NULL;
    
    cmd->argc = 0;
    cmd->argv = (char**)malloc(sizeof(char*) * MAX_ARGS);
    if (!cmd->argv) {
        free(cmd);
        return NULL;
    }

    char* input_copy = strdup(input);
    if (!input_copy) {
        free(cmd->argv);
        free(cmd);
        return NULL;
    }

    char* token = strtok(input_copy, " \t\n");
    while (token && cmd->argc < MAX_ARGS) {
        cmd->argv[cmd->argc] = strdup(token);
        if (!cmd->argv[cmd->argc]) {    //if any argument fails
            for (int i = 0; i < cmd->argc; i++) free(cmd->argv[i]);
            free(cmd->argv);
            free(cmd);
            free(input_copy);
            return NULL;
        }
        cmd->argc++;    //add next argument
        token = strtok(NULL, " \t\n");
    }

    if(NULL != cmd->argv[cmd->argc]){
        printf("%s",input);
        cmd->argv[cmd->argc] = NULL;
    }

    free(input_copy);   //free the input copy
    return cmd;
}
//destructor
void command_destroy(Command* cmd) {
    if (!cmd) return;
    for (int i = 0; i < cmd->argc; i++) {
        free(cmd->argv[i]);
    }
    free(cmd->argv);
    free(cmd);
}
//validator
bool command_is_valid(const Command* cmd) {
    return (cmd && cmd->argv && cmd->argc > 0 && cmd->argc <= MAX_ARGS);
}
//getter
const char* command_get_arg(const Command* cmd, int index) {
    // assert(cmd != NULL);
    // assert(index >= 0);
    // assert(index < cmd->argc);
    if (!cmd || index < 0 || index >= cmd->argc) return NULL;
    return cmd->argv[index];
}
//for debugging command object
void command_print(const Command* cmd) {
    assert(cmd != NULL);
    if (!cmd) return;
    printf("argc = %d\n", cmd->argc);
    printf("argv = [");
    for (int i = 0; i < cmd->argc; i++) {
        printf("\"%s\"", cmd->argv[i]);
        if (i < cmd->argc - 1) printf(", ");
    }
    printf("]\n");
}
//instance methods
bool execute_command(const Command* cmd, Curr_Dir* cwd, char *envp[]){
    assert(NULL != cmd);
    assert(cmd->argc >= 0);
    if(!cmd || cmd->argc < 0) return false;
    if(cmd->argc == 0) return true; //to ask user for next command
    assert(cmd->argc > 0);

    //read the command
    const char* argv_0 = command_get_arg(cmd,0);
    if(!argv_0) return false;
    char* command = strdup(argv_0);
    assert(command != NULL);
    if(!command) return false;  //failure in fetching the command

    //match it with builtins
    if(strcmp(command,"cd") == 0){  //call cd
        const char* argv_1 = command_get_arg(cmd,1);
        if(argv_1){
            char* destination = strdup(argv_1);
            assert(NULL != destination);
            command_cd(destination,cwd);
            free(destination);
            return true;
        }
    }else if(strcmp(command,"ls") == 0){  //call cd
        command_ls(cwd);
    }else if(strcmp(command,"pwd") == 0){  //call cd
        command_pwd(cwd);
    }else{
        int return_code = -1;
        if((return_code = import_command_data(cmd,cwd->path, envp)) < 0){
            if(return_code == COMMAND_EXECUTION_FAILED) fprintf(stderr, "Failure executing command: %s\n", argv_0);
            else if(return_code == COMMAND_NOT_FOUND) fprintf(stderr, "execute_command:Command not found in mounted disk: %s\n", argv_0);
            else fprintf(stderr, "Command execution failed with error code {%d} for command: %s\n", return_code,argv_0);
        }
    }

    free(command);
    return true;
}
//creates a custom NULL terminated arguments
char** create_arguments_for_redirection(const Command* cmd){
    assert(command_is_valid(cmd));
    if(!command_is_valid(cmd)){
        perror("create_arguments_for_redirection: INVALID ARGUMENTS");
        return NULL;
    }
    
    //count the number of arguments before "<"
    int count = 0;
    int i=0;
    while(i<cmd->argc && strcmp(command_get_arg(cmd,i),"<") != 0){
        count++;
        i++;
    }
    assert(strcmp(command_get_arg(cmd,count-1),"<") != 0);

    //create a copy of the new arguments including the NULL terminator argument
    char** filtered_args = malloc((count + 1) * sizeof(char *));
    assert(NULL != filtered_args);
    if(!filtered_args){
        perror("create_arguments_for_redirection: malloc fail");
        return NULL;
    }
    for(int k=0; k<count; k++){
        filtered_args[k] = strdup(command_get_arg(cmd,k));
        if (NULL == filtered_args[k]) {
            perror("create_arguments_for_redirection: strdup fail");
            return NULL;
        }
    }
    assert(strcmp(filtered_args[count-1],"<") != 0);
    //terminate the arguments with NULL so it can be used with fexecve
    filtered_args[count] = NULL;

    assert(strcmp(filtered_args[count-1],"<") != 0);
    assert(filtered_args[count] == NULL);
    return filtered_args;
}


//PIPE COMMANDS OBJECT
// typedef struct{
//     int num_commands;   //total number of commands in the pipe
//     Command** commands; //array of commands
// }Pipe_Commands;
void print_pipe_commands(const Pipe_Commands* pipe_cmds) {
    if (pipe_cmds == NULL) {
        printf("Pipe_Commands is NULL\n");
        return;
    }

    printf("Number of commands in pipe: %d\n", pipe_cmds->num_commands);
    
    for (int i = 0; i < pipe_cmds->num_commands; i++) {
        printf("Command %d:\n", i + 1);
        if (pipe_cmds->commands[i] != NULL) {
            command_print(pipe_cmds->commands[i]);  // Assuming this function exists
        } else {
            printf("  (NULL command)\n");
        }
        
        // Print a separator between commands, except for the last one
        if (i < pipe_cmds->num_commands - 1) {
            printf("  |\n");  // Pipe symbol to visually separate commands
        }
    }
}
Pipe_Commands* create_Pipe_Commands(const int num_pipes, char* line){
    assert(num_pipes > 0);
    assert(is_valid_string(line));
    if(num_pipes <= 0){
        printf("create_Pipe_Commands: INVALID number of pipes {%d}", num_pipes);
        return NULL;
    }
    if(!is_valid_string(line)){
        printf("create_Pipe_Commands: INVALID input command string {%s}", line);
        return NULL;
    }

    //Allocate memory for the Pipe_Commands object
    Pipe_Commands* pipe_commands_obj = malloc(sizeof(Pipe_Commands));
    assert(NULL != pipe_commands_obj);
    if (!pipe_commands_obj) {
        perror("create_Pipe_Commands:: malloc fail - pipe_commands_obj");
        return NULL;
    }

    // Allocate memory for the array of Command pointers
    pipe_commands_obj->commands = malloc((num_pipes+1) * sizeof(Command*));
    Command** cmd_array = pipe_commands_obj->commands;
    if (!cmd_array) {
        perror("create_Pipe_Commands:: malloc fail - commands array");
        pipe_commands_destroy(pipe_commands_obj);
        return NULL;
    }
    pipe_commands_obj->num_commands = num_pipes+1;
    assert(pipe_commands_obj->num_commands == num_pipes+1);

    // Split the line by pipe operators and create a command object for each sub string
    //char *token = strtok(line, "|");
    char* token = NULL;
    char cmd_str[MAX_LINE_SIZE];
    int i = 0;
    int count = 0;
    //printf("TOKEN: {%s}\n",token);
    while ((token = strsep(&line, "|")) != NULL && i < num_pipes+1) {
        count++;
        assert(num_pipes+1 > i);

        //create a copy of command for creating the command
        memset(cmd_str,0,MAX_LINE_SIZE);
        strncpy(cmd_str,token,MAX_LINE_SIZE);

        trim_string(cmd_str);
        assert(is_valid_string(cmd_str));
        //printf("TOKEN: {%s}\n",cmd_str);

        // Create a Command object with the token
        cmd_array[i] = command_create(cmd_str);
        if (!cmd_array[i]) {
            fprintf(stderr, "Failed to create Command object for: %s\n", cmd_str);

            // Clean up on failure
            pipe_commands_destroy(pipe_commands_obj);
            return NULL;
        }
        if(0 == cmd_array[i]->argc){    //invalid command arguments given in line
            fprintf(stderr, "INVALID Command within the pipe\n");
            pipe_commands_destroy(pipe_commands_obj);
            return NULL;
        }

        i++;
    }

    assert(count == pipe_commands_obj->num_commands);
    return pipe_commands_obj;    //! change to pipe commands object
}
void pipe_commands_destroy(Pipe_Commands* pipe) {
    if (pipe == NULL) return;

    // Free individual Command objects
    if (pipe->commands != NULL) {
        for (int i = 0; i < pipe->num_commands; i++) {
            if (pipe->commands[i] != NULL) {
                // Assuming Command has a destructor
                command_destroy(pipe->commands[i]);
            }
        }
        // Free the array of Command pointers
        free(pipe->commands);
    }

    // Free the Pipe_Commands struct itself
    free(pipe);
}
bool pipe_commands_is_valid(const Pipe_Commands* pc) {
    // Check if the struct itself exists
    if (pc == NULL) return false;
    
    // Validate number of commands
    if (pc->num_commands < 1) return false;
    
    // Validate commands array
    if (pc->commands == NULL) return false;
    
    // Validate individual commands
    for (int i = 0; i < pc->num_commands; i++) {
        if (pc->commands[i] == NULL || !command_is_valid(pc->commands[i])) {    //!guess gault
            return false;
        }
    }
    
    // All checks passed
    return true;
}
Command* pipe_commands_get_command_at(const Pipe_Commands* cmd_list, const int index){
    if (!cmd_list || index < 0 || index >= cmd_list->num_commands) return NULL;
    return cmd_list->commands[index];
}
int execute_pipes(Pipe_Commands* cmd_list, const Curr_Dir* cwd, char *envp[], const int output_fd); //something similar feel free to change it or create new if needed

//PIPES RELATED ROUTINES
int calc_num_pipes_marker(const Command* cmd) {
    // Defensive checks for NULL and validity
    assert(cmd != NULL && "calc_num_pipes_marker::Command pointer cannot be NULL");
    if (!command_is_valid(cmd)) {
        printf("INVALID: Arguments => ");
        command_print(cmd);
        return 0;
    }

    int pipe_count = 0;
    
    // Iterate through arguments
    for (int i = 0; i < cmd->argc; i++) {
        const char* arg = command_get_arg(cmd, i);
        assert(arg != NULL && "calc_num_pipes_marker::Command argument cannot be NULL");
        
        // Check for pipe character only if argument is a valid string
        if (is_valid_string(arg) && strcmp(arg, "|") == 0) {
            pipe_count++;
        }
    }
    if(pipe_count > 0 && !validate_pipe_positions(cmd)){    //if pipe exist BUT not used correctly
        pipe_count = INVALID_USECASE; //treat it as pipe not used properly
    }
    return pipe_count;
}
bool validate_pipe_positions(const Command* cmd) {
    // Defensive checks
    assert(cmd != NULL && "Command pointer cannot be NULL");
    if (!command_is_valid(cmd)) return false;
    
    for (int i = 0; i < cmd->argc; i++) {
        const char* arg = command_get_arg(cmd, i);
        assert(arg != NULL && "Command argument cannot be NULL");

        if (strcmp(arg, "|") == 0) {
            
            // Check previous argument exists and is non-pipe
            if (i == 0 || !is_valid_string(command_get_arg(cmd, i-1)) || 
                strcmp(command_get_arg(cmd, i-1), "|") == 0) {
                printf("INVALID USE: of pipe operator => ");
                command_print(cmd);
                return false;
            }

            // Check next argument exists and is non-pipe
            if (i == cmd->argc-1 || !is_valid_string(command_get_arg(cmd, i+1)) || 
                strcmp(command_get_arg(cmd, i+1), "|") == 0) {
                printf("INVALID USE: of pipe operator => ");
                command_print(cmd);
                return false;
            }
        }
    }

    // If no pipes found, still considered valid
    return true;
}



//MAIN FUNCTION
int main( int argc, char *argv[], char *envp[] ){
    char line_buffer[MAX_LINE_SIZE] = {0};

    char *volume_label = NULL;
    nqp_error mount_error;

    if ( argc != 2 && argc != 4){
        fprintf( stderr, "Usage: ./nqp_shell volume.img\n" );
        exit( EXIT_FAILURE );
    }

    mount_error = nqp_mount( argv[1], NQP_FS_EXFAT );

    if ( mount_error != NQP_OK ){
        if ( mount_error == NQP_FSCK_FAIL ){
            fprintf( stderr, "%s is inconsistent, not mounting.\n", argv[1] );
        }
        exit( EXIT_FAILURE );
    }

    volume_label = nqp_vol_label( );

    printf( "%s:\\> ", volume_label );

    //LOG INITIALISING
    if (argc == 4) {    //must have 4 => ./nqp_shell root.img -o log_file.txt
        if (strcmp(argv[2], "-o") != 0) {
            fprintf(stderr, "INVALID Usage: Must be ./nqp_shell volume.img [-o log.txt]\n");
            exit(EXIT_FAILURE);
        }
        
        // Open log file
        log_fd = open(argv[3], O_WRONLY | O_CREAT | O_TRUNC, 0644);
        if (log_fd < 0) {
            perror("Failed to open log file");
            exit(EXIT_FAILURE);
        }
    }

    //TESTING
    //test_all();
    //TESTING

    //Initialise curr_dir with root directory
    Curr_Dir* cwd = construct_empty_curr_dir();
    while (true){
        char mssg[MAX_LINE_SIZE] = {0};
        snprintf(mssg, MAX_LINE_SIZE, "%s:\\> ",volume_label);
        char* line = readline("");
        custom_print(mssg);
        strncpy(line_buffer, line, MAX_LINE_SIZE);

        if (line == NULL) { // EOF (Ctrl+D pressed)
            custom_print("\n");
            break;
        }

        //BONUS PART: Adding the current command to history
        add_history(line_buffer);

        //Parse the command
        Command* new_command = command_create(line_buffer);
        assert(NULL != new_command);
        if(NULL == new_command) return EXIT_FAILURE;

        if(!command_is_valid(new_command)){
            //printf("\nINVALID COMMAND\n");
            command_destroy(new_command);
            continue;   //read next command
        }

        //check if there is any pipe in it
        const int num_pipes = calc_num_pipes_marker(new_command);
        if(num_pipes > 0){
            //printf("Pipes detected\n");

            //create the parsed pipe command arguments
            Pipe_Commands* pipe_cmds = create_Pipe_Commands(num_pipes,line_buffer);
            assert(pipe_commands_is_valid(pipe_cmds));
            if(NULL == pipe_cmds) continue;

            //execute the pipe commands
            int return_code = execute_pipes(pipe_cmds,cwd,envp,STDOUT_FILENO);
            printf("Pipes return code: %d",return_code);
            command_destroy(new_command);
            continue;   //continue reading next command
        }
        if(num_pipes == INVALID_USECASE){
            printf("pipe operator not used properly\n");

            command_destroy(new_command);
            continue;
        }

        //Execute the command if pipes are not present
        if(!execute_command(new_command, cwd, envp) && 0 == num_pipes){
            assert(false);
            custom_print("Failure to execute the command:\n");
            command_print(new_command);

            command_destroy(new_command);
            continue;
        }

        //reset the line buffer for next Command
        memset(line_buffer,0,MAX_LINE_SIZE);
    }

    //free up the resources
    assert(NULL != cwd);
    if(NULL != cwd){
        destroy_curr_dir(cwd);
    }
    free_logs();    //close the log related resources
    return EXIT_SUCCESS;

}


#define _GNU_SOURCE    // For fexecve
#include <sys/mman.h>  // For memfd_create
#include <unistd.h>    // For read, write, fork, lseek
#include <sys/wait.h>  // For waitpid
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>
#include <stdlib.h>
#include "nqp_io.h"
#include "nqp_shell.h"
#include <assert.h>
#include <stdint.h>
#include <ctype.h>
#define LOG_DISABLED -1
#include <fcntl.h>
int log_fd = LOG_DISABLED;#define MAX_ARGS 64
#define MAX_ARG_LENGTH 256
#define READ_BUFFER_SIZE 4096  //1024 * 4
#define COMMAND_NOT_FOUND -404
#define COMMAND_EXECUTION_FAILED -403
#define INVALID_ARGUMENTS -300
#define INSUFFICIENT_ARGUMENTS -301
#define REDIRECTION_FAILED -400
#define INVALID_USECASE -204
#define PIPE_READ_END 0
#define PIPE_WRITE_END 0
#define OPERATION_FAILED -500
#define OPERATION_SUCCEED 500
void custom_print(const char *message) { assert(message != NULL); if (!message) return;  printf("%s",message); fflush(stdout);  if (log_fd != LOG_DISABLED) { write(log_fd, message, strlen(message)); }}void free_logs(){ if (log_fd != LOG_DISABLED) { close(log_fd); }}Curr_Dir* construct_empty_curr_dir(void){  Curr_Dir* cwd = (Curr_Dir*)malloc(sizeof(Curr_Dir)); assert(NULL != cwd); if(NULL == cwd) return NULL;  strncpy(cwd->path, "/", MAX_LINE_SIZE); assert(is_valid_path(cwd->path));  assert(is_valid_curr_dir(cwd)); if(!is_valid_curr_dir(cwd)){  destroy_curr_dir(cwd); return NULL; }  return cwd;}Curr_Dir* construct_curr_dir(const char* path){  assert(is_valid_path(path)); if(!is_valid_path(path)) return NULL;  Curr_Dir* cwd = malloc(sizeof(Curr_Dir)); strncpy(cwd->path, path, MAX_LINE_SIZE);  assert(is_valid_curr_dir(cwd)); if(NULL == cwd) return NULL; if(!is_valid_curr_dir(cwd)){  destroy_curr_dir(cwd); return NULL; }  return cwd;}void destroy_curr_dir(Curr_Dir* cwd){ if(NULL == cwd) return; free(cwd);}void set_path(Curr_Dir* cwd,const char* path){ assert(NULL != cwd); assert(NULL != path); assert(is_valid_path(path)); if(NULL == cwd || NULL == path) return; if(is_valid_curr_dir(cwd)){ strncpy(cwd->path, path, MAX_LINE_SIZE); }}bool is_valid_string(const char* str){ if(NULL == str) return false; if(strlen(str) < 1) return false; if(strlen(str) > MAX_LINE_SIZE) return false; return true;}bool is_only_whitespace(const char *str) { while (*str) { if (!isspace((unsigned char)*str)) { return false; } str++; } return true;}bool is_valid_path(const char* path){ if(NULL == path) return false; if(strlen(path) < 1) return false; if(strlen(path) > MAX_LINE_SIZE) return false; if('/' != path[0]) return false; if(strlen(path) < 1) return false;   int slash_count = 0; for (int i = 0; path[i] != '\0'; i++) { if (path[i] == '/') { slash_count++; if (slash_count >= 2) { return false; } } else { slash_count = 0; } } return true;}bool is_valid_curr_dir(const Curr_Dir *cwd){ if(NULL == cwd) return false; if(!is_valid_path(cwd->path)) return false; return true;}void print_string_array(const char *arr[]) { for (int i = 0; arr[i] != NULL; i++) { printf("%s\n", arr[i]); if(NULL == arr[i+1]){ printf("NULL\n"); } fflush(stdout); }}void command_cd(const char* path, Curr_Dir* cwd);void command_ls(const Curr_Dir* cwd);void command_pwd(const Curr_Dir *cwd);void trim_string(char *str) { if(!str) return; if(strlen(str) < 1) return; int start = 0, end = strlen(str) - 1, i; assert(start <= end); assert(start >= 0); assert(end >= 0);  while (str[start] == ' ' || str[start] == '\t' || str[start] == '\n') start++;  while (end > start && (str[end] == ' ' || str[end] == '\t' || str[end] == '\n')) end--;  for (i = 0; i <= end - start; i++) str[i] = str[start + i];  str[i] = '\0'; assert(is_valid_string(str));}Command* command_create(const char* input) { assert(input != NULL); if (!input) return NULL; Command* cmd = (Command*)malloc(sizeof(Command)); if (!cmd) return NULL; cmd->argc = 0; cmd->argv = (char**)malloc(sizeof(char*) * MAX_ARGS); if (!cmd->argv) { free(cmd); return NULL; } char* input_copy = strdup(input); if (!input_copy) { free(cmd->argv); free(cmd); return NULL; } char* token = strtok(input_copy, " \t\n"); while (token && cmd->argc < MAX_ARGS) { cmd->argv[cmd->argc] = strdup(token); if (!cmd->argv[cmd->argc]) {  for (int i = 0; i < cmd->argc; i++) free(cmd->argv[i]); free(cmd->argv); free(cmd); free(input_copy); return NULL; } cmd->argc++;  token = strtok(NULL, " \t\n"); } if(NULL != cmd->argv[cmd->argc]){ printf("%s",input); cmd->argv[cmd->argc] = NULL; } free(input_copy);  return cmd;}void command_destroy(Command* cmd) { if (!cmd) return; for (int i = 0; i < cmd->argc; i++) { free(cmd->argv[i]); } free(cmd->argv); free(cmd);}bool command_is_valid(const Command* cmd) { return (cmd && cmd->argv && cmd->argc > 0 && cmd->argc <= MAX_ARGS);}const char* command_get_arg(const Command* cmd, int index) {    if (!cmd || index < 0 || index >= cmd->argc) return NULL; return cmd->argv[index];}void command_print(const Command* cmd) { assert(cmd != NULL); if (!cmd) return; printf("argc = %d\n", cmd->argc); printf("argv = ["); for (int i = 0; i < cmd->argc; i++) { printf("\"%s\"", cmd->argv[i]); if (i < cmd->argc - 1) printf(", "); } printf("]\n");}bool execute_command(const Command* cmd, Curr_Dir* cwd, char *envp[]){ assert(NULL != cmd); assert(cmd->argc >= 0); if(!cmd || cmd->argc < 0) return false; if(cmd->argc == 0) return true;  assert(cmd->argc > 0);  const char* argv_0 = command_get_arg(cmd,0); if(!argv_0) return false; char* command = strdup(argv_0); assert(command != NULL); if(!command) return false;   if(strcmp(command,"cd") == 0){  const char* argv_1 = command_get_arg(cmd,1); if(argv_1){ char* destination = strdup(argv_1); assert(NULL != destination); command_cd(destination,cwd); free(destination); return true; } }else if(strcmp(command,"ls") == 0){  command_ls(cwd); }else if(strcmp(command,"pwd") == 0){  command_pwd(cwd); }else{ int return_code = -1; if((return_code = import_command_data(cmd,cwd->path, envp)) < 0){ if(return_code == COMMAND_EXECUTION_FAILED) fprintf(stderr, "Failure executing command: %s\n", argv_0); else if(return_code == COMMAND_NOT_FOUND) fprintf(stderr, "execute_command:Command not found in mounted disk: %s\n", argv_0); else fprintf(stderr, "Command execution failed with error code {%d} for command: %s\n", return_code,argv_0); } } free(command); return true;}char** create_arguments_for_redirection(const Command* cmd){ assert(command_is_valid(cmd)); if(!command_is_valid(cmd)){ perror("create_arguments_for_redirection: INVALID ARGUMENTS"); return NULL; }  int count = 0; int i=0; while(i<cmd->argc && strcmp(command_get_arg(cmd,i),"<") != 0){ count++; i++; } assert(strcmp(command_get_arg(cmd,count-1),"<") != 0);  char** filtered_args = malloc((count + 1) * sizeof(char *)); assert(NULL != filtered_args); if(!filtered_args){ perror("create_arguments_for_redirection: malloc fail"); return NULL; } for(int k=0; k<count; k++){ filtered_args[k] = strdup(command_get_arg(cmd,k)); if (NULL == filtered_args[k]) { perror("create_arguments_for_redirection: strdup fail"); return NULL; } } assert(strcmp(filtered_args[count-1],"<") != 0);  filtered_args[count] = NULL; assert(strcmp(filtered_args[count-1],"<") != 0); assert(filtered_args[count] == NULL); return filtered_args;}void print_pipe_commands(const Pipe_Commands* pipe_cmds) { if (pipe_cmds == NULL) { printf("Pipe_Commands is NULL\n"); return; } printf("Number of commands in pipe: %d\n", pipe_cmds->num_commands); for (int i = 0; i < pipe_cmds->num_commands; i++) { printf("Command %d:\n", i + 1); if (pipe_cmds->commands[i] != NULL) { command_print(pipe_cmds->commands[i]);  } else { printf(" (NULL command)\n"); }  if (i < pipe_cmds->num_commands - 1) { printf(" |\n");  } }}Pipe_Commands* create_Pipe_Commands(const int num_pipes, char* line){ assert(num_pipes > 0); assert(is_valid_string(line)); if(num_pipes <= 0){ printf("create_Pipe_Commands: INVALID number of pipes {%d}", num_pipes); return NULL; } if(!is_valid_string(line)){ printf("create_Pipe_Commands: INVALID input command string {%s}", line); return NULL; }  Pipe_Commands* pipe_commands_obj = malloc(sizeof(Pipe_Commands)); assert(NULL != pipe_commands_obj); if (!pipe_commands_obj) { perror("create_Pipe_Commands:: malloc fail - pipe_commands_obj"); return NULL; }  pipe_commands_obj->commands = malloc((num_pipes+1) * sizeof(Command*)); Command** cmd_array = pipe_commands_obj->commands; if (!cmd_array) { perror("create_Pipe_Commands:: malloc fail - commands array"); pipe_commands_destroy(pipe_commands_obj); return NULL; } pipe_commands_obj->num_commands = num_pipes+1; assert(pipe_commands_obj->num_commands == num_pipes+1);   char* token = NULL; char cmd_str[MAX_LINE_SIZE]; int i = 0; int count = 0;  while ((token = strsep(&line, "|")) != NULL && i < num_pipes+1) { count++; assert(num_pipes+1 > i);  memset(cmd_str,0,MAX_LINE_SIZE); strncpy(cmd_str,token,MAX_LINE_SIZE); trim_string(cmd_str); assert(is_valid_string(cmd_str));   cmd_array[i] = command_create(cmd_str); if (!cmd_array[i]) { fprintf(stderr, "Failed to create Command object for: %s\n", cmd_str);  pipe_commands_destroy(pipe_commands_obj); return NULL; } if(0 == cmd_array[i]->argc){  fprintf(stderr, "INVALID Command within the pipe\n"); pipe_commands_destroy(pipe_commands_obj); return NULL; } i++; } assert(count == pipe_commands_obj->num_commands); return pipe_commands_obj; }void pipe_commands_destroy(Pipe_Commands* pipe) { if (pipe == NULL) return;  if (pipe->commands != NULL) { for (int i = 0; i < pipe->num_commands; i++) { if (pipe->commands[i] != NULL) {  command_destroy(pipe->commands[i]); } }  free(pipe->commands); }  free(pipe);}bool pipe_commands_is_valid(const Pipe_Commands* pc) {  if (pc == NULL) return false;  if (pc->num_commands < 1) return false;  if (pc->commands == NULL) return false;  for (int i = 0; i < pc->num_commands; i++) { if (pc->commands[i] == NULL || !command_is_valid(pc->commands[i])) {  return false; } }  return true;}Command* pipe_commands_get_command_at(const Pipe_Commands* cmd_list, const int index){ if (!cmd_list || index < 0 || index >= cmd_list->num_commands) return NULL; return cmd_list->commands[index];}int execute_pipes(Pipe_Commands* cmd_list, const Curr_Dir* cwd, char *envp[], const int output_fd); int calc_num_pipes_marker(const Command* cmd) {  assert(cmd != NULL && "calc_num_pipes_marker::Command pointer cannot be NULL"); if (!command_is_valid(cmd)) { printf("INVALID: Arguments => "); command_print(cmd); return 0; } int pipe_count = 0;  for (int i = 0; i < cmd->argc; i++) { const char* arg = command_get_arg(cmd, i); assert(arg != NULL && "calc_num_pipes_marker::Command argument cannot be NULL");  if (is_valid_string(arg) && strcmp(arg, "|") == 0) { pipe_count++; } } if(pipe_count > 0 && !validate_pipe_positions(cmd)){  pipe_count = INVALID_USECASE;  } return pipe_count;}bool validate_pipe_positions(const Command* cmd) {  assert(cmd != NULL && "Command pointer cannot be NULL"); if (!command_is_valid(cmd)) return false; for (int i = 0; i < cmd->argc; i++) { const char* arg = command_get_arg(cmd, i); assert(arg != NULL && "Command argument cannot be NULL"); if (strcmp(arg, "|") == 0) {  if (i == 0 || !is_valid_string(command_get_arg(cmd, i-1)) ||  strcmp(command_get_arg(cmd, i-1), "|") == 0) { printf("INVALID USE: of pipe operator => "); command_print(cmd); return false; }  if (i == cmd->argc-1 || !is_valid_string(command_get_arg(cmd, i+1)) ||  strcmp(command_get_arg(cmd, i+1), "|") == 0) { printf("INVALID USE: of pipe operator => "); command_print(cmd); return false; } } }  return true;}int main( int argc, char *argv[], char *envp[] ){ char line_buffer[MAX_LINE_SIZE] = {0}; char *volume_label = NULL; nqp_error mount_error; if ( argc != 2 && argc != 4){ fprintf( stderr, "Usage: ./nqp_shell volume.img\n" ); exit( EXIT_FAILURE ); } mount_error = nqp_mount( argv[1], NQP_FS_EXFAT ); if ( mount_error != NQP_OK ){ if ( mount_error == NQP_FSCK_FAIL ){ fprintf( stderr, "%s is inconsistent, not mounting.\n", argv[1] ); } exit( EXIT_FAILURE ); } volume_label = nqp_vol_label( ); printf( "%s:\\> ", volume_label );  if (argc == 4) {  if (strcmp(argv[2], "-o") != 0) { fprintf(stderr, "INVALID Usage: Must be ./nqp_shell volume.img [-o log.txt]\n"); exit(EXIT_FAILURE); }  log_fd = open(argv[3], O_WRONLY | O_CREAT | O_TRUNC, 0644); if (log_fd < 0) { perror("Failed to open log file"); exit(EXIT_FAILURE); } }     Curr_Dir* cwd = construct_empty_curr_dir(); while (true){ char mssg[MAX_LINE_SIZE] = {0}; snprintf(mssg, MAX_LINE_SIZE, "%s:\\> ",volume_label); char* line = readline(""); custom_print(mssg); strncpy(line_buffer, line, MAX_LINE_SIZE); if (line == NULL) {  custom_print("\n"); break; }  add_history(line_buffer);  Command* new_command = command_create(line_buffer); assert(NULL != new_command); if(NULL == new_command) return EXIT_FAILURE; if(!command_is_valid(new_command)){  command_destroy(new_command); continue;  }  const int num_pipes = calc_num_pipes_marker(new_command); if(num_pipes > 0){   Pipe_Commands* pipe_cmds = create_Pipe_Commands(num_pipes,line_buffer); assert(pipe_commands_is_valid(pipe_cmds)); if(NULL == pipe_cmds) continue;  int return_code = execute_pipes(pipe_cmds,cwd,envp,STDOUT_FILENO); printf("Pipes return code: %d",return_code); command_destroy(new_command); continue;  } if(num_pipes == INVALID_USECASE){ printf("pipe operator not used properly\n"); command_destroy(new_command); continue; }  if(!execute_command(new_command, cwd, envp) && 0 == num_pipes){ assert(false); custom_print("Failure to execute the command:\n"); command_print(new_command); command_destroy(new_command); continue; }  memset(line_buffer,0,MAX_LINE_SIZE); }  assert(NULL != cwd); if(NULL != cwd){ destroy_curr_dir(cwd); } free_logs();  return EXIT_SUCCESS;}