#define _GNU_SOURCE    // For fexecve
#include <sys/mman.h>  // For memfd_create
#include <unistd.h>    // For read, write, fork, lseek
#include <sys/wait.h>  // For waitpid

//for the bonus part: navigating the history
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

#include <stdlib.h>

#include "nqp_io.h"
#include "nqp_shell.h"

#include <assert.h>
#include <stdint.h>
#include <ctype.h>


//COMMAND RELATED CONSTANTS
#define MAX_ARGS 64
#define MAX_ARG_LENGTH 256
#define READ_BUFFER_SIZE 4096  //1024 * 4
#define COMMAND_NOT_FOUND -404
#define COMMAND_EXECUTION_FAILED -403
#define INVALID_ARGUMENTS -300
#define INSUFFICIENT_ARGUMENTS -301
#define REDIRECTION_FAILED -400
#define INVALID_USECASE -204
#define PIPE_READ_END 0
#define PIPE_WRITE_END 0
#define OPERATION_FAILED -500
#define OPERATION_SUCCEED 500



//CURRENT DIRECTORY STRUCT
// typedef struct{
//     char path[MAX_LINE_SIZE];
// } Curr_Dir;
Curr_Dir* construct_empty_curr_dir(void){
    //create struct
    Curr_Dir* cwd = (Curr_Dir*)malloc(sizeof(Curr_Dir));
    assert(NULL != cwd);
    if(NULL == cwd) return NULL;

    //initialize with root directory path
    strncpy(cwd->path, "/", MAX_LINE_SIZE);
    assert(is_valid_path(cwd->path));

    //verify it
    assert(is_valid_curr_dir(cwd));
    if(!is_valid_curr_dir(cwd)){    //invalid struct hence free it
        destroy_curr_dir(cwd);
        return NULL;
    }

    //return it
    return cwd;
}
Curr_Dir* construct_curr_dir(const char* path){
    //input validation
    assert(is_valid_path(path));
    if(!is_valid_path(path)) return NULL;

    //create struct
    Curr_Dir* cwd = malloc(sizeof(Curr_Dir));
    strncpy(cwd->path, path, MAX_LINE_SIZE);

    //verify it
    assert(is_valid_curr_dir(cwd));
    if(NULL == cwd) return NULL;
    if(!is_valid_curr_dir(cwd)){    //invalid struct hence free it
        destroy_curr_dir(cwd);
        return NULL;
    }

    //return it
    return cwd;
}
void destroy_curr_dir(Curr_Dir* cwd){
    if(NULL == cwd) return;
    free(cwd);
}
void set_path(Curr_Dir* cwd,const char* path){
    assert(NULL != cwd);
    assert(NULL != path);
    assert(is_valid_path(path));
    if(NULL == cwd || NULL == path) return;
    if(is_valid_curr_dir(cwd)){
        strncpy(cwd->path, path, MAX_LINE_SIZE);
    }
}

//VALIDATORS
bool is_valid_string(const char* str){
    if(NULL == str) return false;
    if(strlen(str) < 1) return false;
    if(strlen(str) > MAX_LINE_SIZE) return false;
    return true;
}
bool is_only_whitespace(const char *str) {
    while (*str) {
        if (!isspace((unsigned char)*str)) {
            return false;
        }
        str++;
    }
    return true;
}
bool is_valid_path(const char* path){
    if(NULL == path) return false;
    if(strlen(path) < 1) return false;
    if(strlen(path) > MAX_LINE_SIZE) return false;
    if('/' != path[0]) return false;
    if(strlen(path) < 1) return false;
    //if('/' != path[strlen(path)-1]) return false;
    //making sure if path do not contain consecutive "/"
    int slash_count = 0;
    for (int i = 0; path[i] != '\0'; i++) {
        if (path[i] == '/') {
            slash_count++;
            if (slash_count >= 2) {
                return false;
            }
        } else {
            slash_count = 0;
        }
    }
    return true;
}
bool is_valid_curr_dir(const Curr_Dir *cwd){
    if(NULL == cwd) return false;
    if(!is_valid_path(cwd->path)) return false;
    return true;
}
void print_string_array(const char *arr[]) {
    for (int i = 0; arr[i] != NULL; i++) {
        printf("%s\n", arr[i]);
        if(NULL == arr[i+1]){
            printf("NULL\n");
        }
        fflush(stdout);
    }
    
}

//builtins
void command_cd(const char* path, Curr_Dir* cwd);
void command_ls(const Curr_Dir* cwd);
void command_pwd(const Curr_Dir *cwd);


//HELPERS
void trim_string(char *str) {
    if(!str) return;
    if(strlen(str) < 1) return;
    int start = 0, end = strlen(str) - 1, i;
    assert(start <= end);
    assert(start >= 0);
    assert(end >= 0);
    // Trim leading whitespace
    while (str[start] == ' ' || str[start] == '\t' || str[start] == '\n') start++;

    // Trim trailing whitespace
    while (end > start && (str[end] == ' ' || str[end] == '\t' || str[end] == '\n')) end--;

    // Shift characters to the beginning of the string
    for (i = 0; i <= end - start; i++) str[i] = str[start + i];

    // Null terminate the string
    str[i] = '\0';
    assert(is_valid_string(str));
}
//COMMAND OBJECT ROUTINES
// typedef struct {
//     int argc;
//     char** argv;
// } Command;
//constructor
Command* command_create(const char* input) {
    assert(input != NULL);
    if (!input) return NULL;

    Command* cmd = (Command*)malloc(sizeof(Command));
    if (!cmd) return NULL;
    
    cmd->argc = 0;
    cmd->argv = (char**)malloc(sizeof(char*) * MAX_ARGS);
    if (!cmd->argv) {
        free(cmd);
        return NULL;
    }

    char* input_copy = strdup(input);
    if (!input_copy) {
        free(cmd->argv);
        free(cmd);
        return NULL;
    }

    char* token = strtok(input_copy, " \t\n");
    while (token && cmd->argc < MAX_ARGS) {
        cmd->argv[cmd->argc] = strdup(token);
        if (!cmd->argv[cmd->argc]) {    //if any argument fails
            for (int i = 0; i < cmd->argc; i++) free(cmd->argv[i]);
            free(cmd->argv);
            free(cmd);
            free(input_copy);
            return NULL;
        }
        cmd->argc++;    //add next argument
        token = strtok(NULL, " \t\n");
    }

    if(NULL != cmd->argv[cmd->argc]){
        printf("%s",input);
        cmd->argv[cmd->argc] = NULL;
    }

    free(input_copy);   //free the input copy
    return cmd;
}
//destructor
void command_destroy(Command* cmd) {
    if (!cmd) return;
    for (int i = 0; i < cmd->argc; i++) {
        free(cmd->argv[i]);
    }
    free(cmd->argv);
    free(cmd);
}
//validator
bool command_is_valid(const Command* cmd) {
    return (cmd && cmd->argv && cmd->argc > 0 && cmd->argc <= MAX_ARGS);
}
//getter
const char* command_get_arg(const Command* cmd, int index) {
    // assert(cmd != NULL);
    // assert(index >= 0);
    // assert(index < cmd->argc);
    if (!cmd || index < 0 || index >= cmd->argc) return NULL;
    return cmd->argv[index];
}
//for debugging command object
void command_print(const Command* cmd) {
    assert(cmd != NULL);
    if (!cmd) return;
    printf("argc = %d\n", cmd->argc);
    printf("argv = [");
    for (int i = 0; i < cmd->argc; i++) {
        printf("\"%s\"", cmd->argv[i]);
        if (i < cmd->argc - 1) printf(", ");
    }
    printf("]\n");
}
//instance methods
bool execute_command(const Command* cmd, Curr_Dir* cwd, char *envp[]){
    assert(NULL != cmd);
    assert(cmd->argc >= 0);
    if(!cmd || cmd->argc < 0) return false;
    if(cmd->argc == 0) return true; //to ask user for next command
    assert(cmd->argc > 0);

    //read the command
    const char* argv_0 = command_get_arg(cmd,0);
    if(!argv_0) return false;
    char* command = strdup(argv_0);
    assert(command != NULL);
    if(!command) return false;  //failure in fetching the command

    //match it with builtins
    if(strcmp(command,"cd") == 0){  //call cd
        const char* argv_1 = command_get_arg(cmd,1);
        if(argv_1){
            char* destination = strdup(argv_1);
            assert(NULL != destination);
            command_cd(destination,cwd);
            free(destination);
            return true;
        }
    }else if(strcmp(command,"ls") == 0){  //call cd
        command_ls(cwd);
    }else if(strcmp(command,"pwd") == 0){  //call cd
        command_pwd(cwd);
    }else{
        int return_code = -1;
        if((return_code = import_command_data(cmd,cwd->path, envp)) < 0){
            if(return_code == COMMAND_EXECUTION_FAILED) fprintf(stderr, "Failure executing command: %s\n", argv_0);
            else if(return_code == COMMAND_NOT_FOUND) fprintf(stderr, "execute_command:Command not found in mounted disk: %s\n", argv_0);
            else fprintf(stderr, "Command execution failed with error code {%d} for command: %s\n", return_code,argv_0);
        }
    }

    free(command);
    return true;
}
//creates a custom NULL terminated arguments
char** create_arguments_for_redirection(const Command* cmd){
    assert(command_is_valid(cmd));
    if(!command_is_valid(cmd)){
        perror("create_arguments_for_redirection: INVALID ARGUMENTS");
        return NULL;
    }
    
    //count the number of arguments before "<"
    int count = 0;
    int i=0;
    while(i<cmd->argc && strcmp(command_get_arg(cmd,i),"<") != 0){
        count++;
        i++;
    }
    assert(strcmp(command_get_arg(cmd,count-1),"<") != 0);

    //create a copy of the new arguments including the NULL terminator argument
    char** filtered_args = malloc((count + 1) * sizeof(char *));
    assert(NULL != filtered_args);
    if(!filtered_args){
        perror("create_arguments_for_redirection: malloc fail");
        return NULL;
    }
    for(int k=0; k<count; k++){
        filtered_args[k] = strdup(command_get_arg(cmd,k));
        if (NULL == filtered_args[k]) {
            perror("create_arguments_for_redirection: strdup fail");
            return NULL;
        }
    }
    assert(strcmp(filtered_args[count-1],"<") != 0);
    //terminate the arguments with NULL so it can be used with fexecve
    filtered_args[count] = NULL;

    assert(strcmp(filtered_args[count-1],"<") != 0);
    assert(filtered_args[count] == NULL);
    return filtered_args;
}


//PROCESS RELATED ROUTINES
int import_command_to_memfd(const char* path) {
    assert(path != NULL); 
    if(!is_valid_path(path)){
        printf("INVALID PATH: {%s}\n",path);
        return COMMAND_NOT_FOUND;
    }
    assert(is_valid_path(path));    //! path is invalid
    if (!path) {
        printf("INVALID file path to search in mounted filesystem\n");
        return COMMAND_NOT_FOUND;
    }
    
    // Open the file in the nqp filesystem
    int nqp_fd = nqp_open(path);
    if (nqp_fd == NQP_FILE_NOT_FOUND) {
        printf("import_command_to_memfd:Command Not Found in mounted filesystem {%s}\n", path);
        return COMMAND_NOT_FOUND;
    }
    
    // Create a memory file to store the command
    int mem_fd = memfd_create(path, 0);
    if (mem_fd < 0) {   //file creation failed
        nqp_close(nqp_fd);
        return COMMAND_EXECUTION_FAILED;
    }
    
    // Read the command file from NQP filesystem and write to memory file
    lseek(mem_fd, 0, SEEK_SET);
    char buffer[READ_BUFFER_SIZE] = {0};
    ssize_t bytes_read;
    while ((bytes_read = nqp_read(nqp_fd, buffer, READ_BUFFER_SIZE)) > 0) {
        write(mem_fd, buffer, bytes_read);
        memset(buffer, 0, READ_BUFFER_SIZE);    //reset the buffer
    }
    
    // Close the NQP file and reset the memory file position
    nqp_close(nqp_fd);
    lseek(mem_fd, 0, SEEK_SET);
    
    return mem_fd;
}
int import_command_data(const Command* cmd, const char* curr_path, char *envp[]){
    const char* argv_0 = command_get_arg(cmd,0);
    char* command = strdup(argv_0);
    char* path = strdup(curr_path);
    assert(is_valid_path(path));
    assert(is_valid_string(command));
    if(!is_valid_path(path) || !is_valid_string(command)){
        free(command);
        return COMMAND_NOT_FOUND;
    }
    
    //search the command data file in current working directory
    //first change the command path to start from the root directory
    if(path[strlen(path)-1] != '/'){
        strcat(path,"/");       //make sure the working directory path ends with "/"
    }
    strcat(path,command);   //concatenate the command to that path
    
    //open the file in nqp file system
    int nqp_fd = nqp_open(path);
    if(nqp_fd == NQP_FILE_NOT_FOUND){
        free(command);
        return COMMAND_NOT_FOUND;
    }
    assert(nqp_fd >= 0);
    free(path); //path is no longer needed so free it

    //write the executable into new memory space
    int mem_fd = memfd_create("FileSystemCode", 0); 
    if(mem_fd == NQP_FILE_NOT_FOUND) {
        nqp_close(nqp_fd);
        free(command);
        return COMMAND_NOT_FOUND;
    }
    assert(mem_fd >= 0);

    //read the file's data from the nqp file system and write in the mem_fd file
    char buffer[READ_BUFFER_SIZE] = {0};
    int bytes_read = 0;
    while( (bytes_read = nqp_read(nqp_fd, &buffer, READ_BUFFER_SIZE)) > 0){
        write(mem_fd, buffer, bytes_read);
        memset(buffer, 0, READ_BUFFER_SIZE);
    }

    //close the file in nqp file system and reset the offset marker in mem_fd file
    nqp_close(nqp_fd);  
    lseek(mem_fd, 0, SEEK_SET);

    //split the process
    pid_t pid = fork();
    if(0 == pid){   //child process
        //verify arguments
        char** arguments = cmd->argv;

        //handle the redirection
        int input_fd = -1;
        input_fd = handle_input_redirection(cmd,curr_path);
        if (input_fd > 0) { //if input_fd is different than STDIN_FILENO then redirection is enabled
            //if redirection is required, change the file descriptor of stdin with input_fd
            dup2(input_fd, STDIN_FILENO);
            close(input_fd);

            //update the arguments since redirection is enabled
            char **minimal_args = create_arguments_for_redirection(cmd);    //! FREE THIS AFTER USE
            arguments = minimal_args;
            assert(minimal_args != NULL);
        }
        if(REDIRECTION_FAILED == input_fd){ //there was a redirection operator and it failed
            printf("Redirection Failed pls try again\n");   //terminate the process 
            exit(EXIT_FAILURE);
        }       
        if(INVALID_ARGUMENTS == input_fd){
            printf("Invalid Arguments passed to redirection command");
        }
        // Execute program
        fexecve(mem_fd, arguments, envp);
        printf("import_command_data::fexecve FAILED\n");
        exit(EXIT_FAILURE);
    } else if (pid > 0) {   // Parent process
        assert(pid != 0);   //trigger means fexecve failed. Currently in child process
        // Parent process
        int status;         //status code for whether waitpid was executed or not
        waitpid(pid, &status, 0);
        
        free(command);
        return status;
    }

    return COMMAND_EXECUTION_FAILED;
}
int handle_input_redirection(const Command* cmd, const char* cwd_path){
    assert(command_is_valid(cmd));
    assert(cwd_path != NULL);
    assert(is_valid_path(cwd_path));
    if(NULL == cmd || NULL == cwd_path) return INVALID_ARGUMENTS;
    if(!command_is_valid(cmd) || !is_valid_path(cwd_path)) return INVALID_ARGUMENTS;

    //loop through the command arguments
    for(int i=0; i<cmd->argc; i++){
        //search for "<" in the arguments
        if(strcmp(command_get_arg(cmd,i),"<") == 0){ //detected redirection operator
            //check if redirection is possible or not, if the command contains "<" operator
            if(cmd->argc < 3){
                printf("ERROR: Not enough arguments for redirection, Minimum 3 arguments required\n");
                return REDIRECTION_FAILED;
            }
            if(i+1 >= cmd->argc){    //making sure the redirection operator isn't the last argument
                printf("ERROR: Last argument should be a filename not the redirection operator\n");
                return REDIRECTION_FAILED;
            }

            //open the input file
            const char* arg_i_plus_one = command_get_arg(cmd,i+1);
            assert(arg_i_plus_one != NULL);
            char* filename = strdup(arg_i_plus_one);    //stores the filename for creating filepath
            assert(NULL != filename);
            char* filepath = strdup(cwd_path);          //stores the absolute path in nqp file system
            assert(NULL != filepath);
            if(NULL == filename || NULL == filepath){
                printf("ERROR: error in finding file from the arguments of the command ");
                command_print(cmd);
                free(filename);
                free(filepath);
                return REDIRECTION_FAILED;
            }
            //create the absolute path of the filename for the nqp file system
            if(filepath[strlen(filepath)-1] != '/'){
                strcat(filepath,"/");   //make sure cwd_path ends with "/"
            }
            strcat(filepath,filename);  //making filepath absolute
            assert(is_valid_path(filepath));

            //open that file in nqp file system
            int input_fd = nqp_open(filepath);
            if(input_fd < 0){
                printf("Redirection Error: nqp_open input file {%s} not found\n", command_get_arg(cmd,i+1));
                return REDIRECTION_FAILED;
            }
            assert(input_fd >= 0);

            //create a memory file to store the input file
            int mem_fd = memfd_create(filepath, 0);
            if (mem_fd < 0) {
                printf("ERROR: memfd_create can't create input_redirect");
                nqp_close(input_fd);    //free resources
                return REDIRECTION_FAILED;
            }
            assert(mem_fd >= 0);

            //read the input file and write it in the memory file
            char buffer[READ_BUFFER_SIZE] = {0};
            ssize_t bytes_read = 0;
            while ((bytes_read = nqp_read(input_fd, buffer, sizeof(buffer))) > 0) {
                write(mem_fd, &buffer, bytes_read);     //write it in the memory file
                memset(buffer, 0, READ_BUFFER_SIZE);    //reset the buffer
            }
            nqp_close(input_fd);            //close the input file in the nqp file system
            lseek(mem_fd, 0, SEEK_SET);     //reset read offset of the memory input file

            printf("handle_input_redirection: memfd = {%d}\n", mem_fd);
            return mem_fd;  //return the fd of memory input file
        }
    }
    //if there is no redirection needed, then return the standard input file num
    return STDIN_FILENO;
}
//MAIN FUNCTION
int main( int argc, char *argv[], char *envp[] ){
    char line_buffer[MAX_LINE_SIZE] = {0};

    char *volume_label = NULL;
    nqp_error mount_error;

    if ( argc != 2 ){
        fprintf( stderr, "Usage: ./nqp_shell volume.img\n" );
        exit( EXIT_FAILURE );
    }

    mount_error = nqp_mount( argv[1], NQP_FS_EXFAT );

    if ( mount_error != NQP_OK ){
        if ( mount_error == NQP_FSCK_FAIL ){
            fprintf( stderr, "%s is inconsistent, not mounting.\n", argv[1] );
        }
        exit( EXIT_FAILURE );
    }

    volume_label = nqp_vol_label( );

    printf( "%s:\\> ", volume_label );

    //TESTING
    //test_all();
    //TESTING

    //Initialise curr_dir with root directory
    Curr_Dir* cwd = construct_empty_curr_dir();
    while (true){
        char mssg[MAX_LINE_SIZE] = {0};
        snprintf(mssg, MAX_LINE_SIZE, "%s:\\> ",volume_label);
        char* line = readline(mssg);
        strncpy(line_buffer, line, MAX_LINE_SIZE);

        if (line == NULL) { // EOF (Ctrl+D pressed)
            printf("\n");
            break;
        }

        //BONUS PART: Adding the current command to history
        add_history(line_buffer);

        //Parse the command
        Command* new_command = command_create(line_buffer);
        assert(NULL != new_command);
        if(NULL == new_command) return EXIT_FAILURE;

        if(!command_is_valid(new_command)){
            //printf("\nINVALID COMMAND\n");
            command_destroy(new_command);
            continue;   //read next command
        }

        //check if there is any pipe in it
        const int num_pipes = calc_num_pipes_marker(new_command);
        if(num_pipes > 0){
            //printf("Pipes detected\n");

            //create the parsed pipe command arguments
            Pipe_Commands* pipe_cmds = create_Pipe_Commands(num_pipes,line_buffer);
            assert(pipe_commands_is_valid(pipe_cmds));
            if(NULL == pipe_cmds) continue;

            //execute the pipe commands
            int return_code = execute_pipes(pipe_cmds,cwd,envp,STDOUT_FILENO);
            printf("Pipes return code: %d",return_code);
            command_destroy(new_command);
            continue;   //continue reading next command
        }
        if(num_pipes == INVALID_USECASE){
            printf("pipe operator not used properly\n");

            command_destroy(new_command);
            continue;
        }

        //Execute the command if pipes are not present
        if(!execute_command(new_command, cwd, envp) && 0 == num_pipes){
            assert(false);
            printf("Failure to execute the command:\n");
            command_print(new_command);

            command_destroy(new_command);
            continue;
        }

        //reset the line buffer for next Command
        memset(line_buffer,0,MAX_LINE_SIZE);
    }

    //free up the resources
    assert(NULL != cwd);
    if(NULL != cwd){
        destroy_curr_dir(cwd);
    }
    return EXIT_SUCCESS;

}

#define _GNU_SOURCE    // For fexecve
#include <sys/mman.h>  // For memfd_create
#include <unistd.h>    // For read, write, fork, lseek
#include <sys/wait.h>  // For waitpid
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>
#include <stdlib.h>
#include "nqp_io.h"
#include "nqp_shell.h"
#include <assert.h>
#include <stdint.h>
#include <ctype.h>
#define MAX_ARGS 64
#define MAX_ARG_LENGTH 256
#define READ_BUFFER_SIZE 4096  //1024 * 4
#define COMMAND_NOT_FOUND -404
#define COMMAND_EXECUTION_FAILED -403
#define INVALID_ARGUMENTS -300
#define INSUFFICIENT_ARGUMENTS -301
#define REDIRECTION_FAILED -400
#define INVALID_USECASE -204
#define PIPE_READ_END 0
#define PIPE_WRITE_END 0
#define OPERATION_FAILED -500
#define OPERATION_SUCCEED 500
Curr_Dir* construct_empty_curr_dir(void){  Curr_Dir* cwd = (Curr_Dir*)malloc(sizeof(Curr_Dir)); assert(NULL != cwd); if(NULL == cwd) return NULL;  strncpy(cwd->path, "/", MAX_LINE_SIZE); assert(is_valid_path(cwd->path));  assert(is_valid_curr_dir(cwd)); if(!is_valid_curr_dir(cwd)){  destroy_curr_dir(cwd); return NULL; }  return cwd;}Curr_Dir* construct_curr_dir(const char* path){  assert(is_valid_path(path)); if(!is_valid_path(path)) return NULL;  Curr_Dir* cwd = malloc(sizeof(Curr_Dir)); strncpy(cwd->path, path, MAX_LINE_SIZE);  assert(is_valid_curr_dir(cwd)); if(NULL == cwd) return NULL; if(!is_valid_curr_dir(cwd)){  destroy_curr_dir(cwd); return NULL; }  return cwd;}void destroy_curr_dir(Curr_Dir* cwd){ if(NULL == cwd) return; free(cwd);}void set_path(Curr_Dir* cwd,const char* path){ assert(NULL != cwd); assert(NULL != path); assert(is_valid_path(path)); if(NULL == cwd || NULL == path) return; if(is_valid_curr_dir(cwd)){ strncpy(cwd->path, path, MAX_LINE_SIZE); }}bool is_valid_string(const char* str){ if(NULL == str) return false; if(strlen(str) < 1) return false; if(strlen(str) > MAX_LINE_SIZE) return false; return true;}bool is_only_whitespace(const char *str) { while (*str) { if (!isspace((unsigned char)*str)) { return false; } str++; } return true;}bool is_valid_path(const char* path){ if(NULL == path) return false; if(strlen(path) < 1) return false; if(strlen(path) > MAX_LINE_SIZE) return false; if('/' != path[0]) return false; if(strlen(path) < 1) return false;   int slash_count = 0; for (int i = 0; path[i] != '\0'; i++) { if (path[i] == '/') { slash_count++; if (slash_count >= 2) { return false; } } else { slash_count = 0; } } return true;}bool is_valid_curr_dir(const Curr_Dir *cwd){ if(NULL == cwd) return false; if(!is_valid_path(cwd->path)) return false; return true;}void print_string_array(const char *arr[]) { for (int i = 0; arr[i] != NULL; i++) { printf("%s\n", arr[i]); if(NULL == arr[i+1]){ printf("NULL\n"); } fflush(stdout); }}void command_cd(const char* path, Curr_Dir* cwd);void command_ls(const Curr_Dir* cwd);void command_pwd(const Curr_Dir *cwd);void trim_string(char *str) { if(!str) return; if(strlen(str) < 1) return; int start = 0, end = strlen(str) - 1, i; assert(start <= end); assert(start >= 0); assert(end >= 0);  while (str[start] == ' ' || str[start] == '\t' || str[start] == '\n') start++;  while (end > start && (str[end] == ' ' || str[end] == '\t' || str[end] == '\n')) end--;  for (i = 0; i <= end - start; i++) str[i] = str[start + i];  str[i] = '\0'; assert(is_valid_string(str));}Command* command_create(const char* input) { assert(input != NULL); if (!input) return NULL; Command* cmd = (Command*)malloc(sizeof(Command)); if (!cmd) return NULL; cmd->argc = 0; cmd->argv = (char**)malloc(sizeof(char*) * MAX_ARGS); if (!cmd->argv) { free(cmd); return NULL; } char* input_copy = strdup(input); if (!input_copy) { free(cmd->argv); free(cmd); return NULL; } char* token = strtok(input_copy, " \t\n"); while (token && cmd->argc < MAX_ARGS) { cmd->argv[cmd->argc] = strdup(token); if (!cmd->argv[cmd->argc]) {  for (int i = 0; i < cmd->argc; i++) free(cmd->argv[i]); free(cmd->argv); free(cmd); free(input_copy); return NULL; } cmd->argc++;  token = strtok(NULL, " \t\n"); } if(NULL != cmd->argv[cmd->argc]){ printf("%s",input); cmd->argv[cmd->argc] = NULL; } free(input_copy);  return cmd;}void command_destroy(Command* cmd) { if (!cmd) return; for (int i = 0; i < cmd->argc; i++) { free(cmd->argv[i]); } free(cmd->argv); free(cmd);}bool command_is_valid(const Command* cmd) { return (cmd && cmd->argv && cmd->argc > 0 && cmd->argc <= MAX_ARGS);}const char* command_get_arg(const Command* cmd, int index) {    if (!cmd || index < 0 || index >= cmd->argc) return NULL; return cmd->argv[index];}void command_print(const Command* cmd) { assert(cmd != NULL); if (!cmd) return; printf("argc = %d\n", cmd->argc); printf("argv = ["); for (int i = 0; i < cmd->argc; i++) { printf("\"%s\"", cmd->argv[i]); if (i < cmd->argc - 1) printf(", "); } printf("]\n");}bool execute_command(const Command* cmd, Curr_Dir* cwd, char *envp[]){ assert(NULL != cmd); assert(cmd->argc >= 0); if(!cmd || cmd->argc < 0) return false; if(cmd->argc == 0) return true;  assert(cmd->argc > 0);  const char* argv_0 = command_get_arg(cmd,0); if(!argv_0) return false; char* command = strdup(argv_0); assert(command != NULL); if(!command) return false;   if(strcmp(command,"cd") == 0){  const char* argv_1 = command_get_arg(cmd,1); if(argv_1){ char* destination = strdup(argv_1); assert(NULL != destination); command_cd(destination,cwd); free(destination); return true; } }else if(strcmp(command,"ls") == 0){  command_ls(cwd); }else if(strcmp(command,"pwd") == 0){  command_pwd(cwd); }else{ int return_code = -1; if((return_code = import_command_data(cmd,cwd->path, envp)) < 0){ if(return_code == COMMAND_EXECUTION_FAILED) fprintf(stderr, "Failure executing command: %s\n", argv_0); else if(return_code == COMMAND_NOT_FOUND) fprintf(stderr, "execute_command:Command not found in mounted disk: %s\n", argv_0); else fprintf(stderr, "Command execution failed with error code {%d} for command: %s\n", return_code,argv_0); } } free(command); return true;}char** create_arguments_for_redirection(const Command* cmd){ assert(command_is_valid(cmd)); if(!command_is_valid(cmd)){ perror("create_arguments_for_redirection: INVALID ARGUMENTS"); return NULL; }  int count = 0; int i=0; while(i<cmd->argc && strcmp(command_get_arg(cmd,i),"<") != 0){ count++; i++; } assert(strcmp(command_get_arg(cmd,count-1),"<") != 0);  char** filtered_args = malloc((count + 1) * sizeof(char *)); assert(NULL != filtered_args); if(!filtered_args){ perror("create_arguments_for_redirection: malloc fail"); return NULL; } for(int k=0; k<count; k++){ filtered_args[k] = strdup(command_get_arg(cmd,k)); if (NULL == filtered_args[k]) { perror("create_arguments_for_redirection: strdup fail"); return NULL; } } assert(strcmp(filtered_args[count-1],"<") != 0);  filtered_args[count] = NULL; assert(strcmp(filtered_args[count-1],"<") != 0); assert(filtered_args[count] == NULL); return filtered_args;}int import_command_to_memfd(const char* path) { assert(path != NULL);  if(!is_valid_path(path)){ printf("INVALID PATH: {%s}\n",path); return COMMAND_NOT_FOUND; } assert(is_valid_path(path));  if (!path) { printf("INVALID file path to search in mounted filesystem\n"); return COMMAND_NOT_FOUND; }  int nqp_fd = nqp_open(path); if (nqp_fd == NQP_FILE_NOT_FOUND) { printf("import_command_to_memfd:Command Not Found in mounted filesystem {%s}\n", path); return COMMAND_NOT_FOUND; }  int mem_fd = memfd_create(path, 0); if (mem_fd < 0) {  nqp_close(nqp_fd); return COMMAND_EXECUTION_FAILED; }  lseek(mem_fd, 0, SEEK_SET); char buffer[READ_BUFFER_SIZE] = {0}; ssize_t bytes_read; while ((bytes_read = nqp_read(nqp_fd, buffer, READ_BUFFER_SIZE)) > 0) { write(mem_fd, buffer, bytes_read); memset(buffer, 0, READ_BUFFER_SIZE);  }  nqp_close(nqp_fd); lseek(mem_fd, 0, SEEK_SET); return mem_fd;}int import_command_data(const Command* cmd, const char* curr_path, char *envp[]){ const char* argv_0 = command_get_arg(cmd,0); char* command = strdup(argv_0); char* path = strdup(curr_path); assert(is_valid_path(path)); assert(is_valid_string(command)); if(!is_valid_path(path) || !is_valid_string(command)){ free(command); return COMMAND_NOT_FOUND; }   if(path[strlen(path)-1] != '/'){ strcat(path,"/");  } strcat(path,command);   int nqp_fd = nqp_open(path); if(nqp_fd == NQP_FILE_NOT_FOUND){ free(command); return COMMAND_NOT_FOUND; } assert(nqp_fd >= 0); free(path);   int mem_fd = memfd_create("FileSystemCode", 0);  if(mem_fd == NQP_FILE_NOT_FOUND) { nqp_close(nqp_fd); free(command); return COMMAND_NOT_FOUND; } assert(mem_fd >= 0);  char buffer[READ_BUFFER_SIZE] = {0}; int bytes_read = 0; while( (bytes_read = nqp_read(nqp_fd, &buffer, READ_BUFFER_SIZE)) > 0){ write(mem_fd, buffer, bytes_read); memset(buffer, 0, READ_BUFFER_SIZE); }  nqp_close(nqp_fd);  lseek(mem_fd, 0, SEEK_SET);  pid_t pid = fork(); if(0 == pid){   char** arguments = cmd->argv;  int input_fd = -1; input_fd = handle_input_redirection(cmd,curr_path); if (input_fd > 0) {   dup2(input_fd, STDIN_FILENO); close(input_fd);  char **minimal_args = create_arguments_for_redirection(cmd);  arguments = minimal_args; assert(minimal_args != NULL); } if(REDIRECTION_FAILED == input_fd){  printf("Redirection Failed pls try again\n");  exit(EXIT_FAILURE); }  if(INVALID_ARGUMENTS == input_fd){ printf("Invalid Arguments passed to redirection command"); }  fexecve(mem_fd, arguments, envp); printf("import_command_data::fexecve FAILED\n"); exit(EXIT_FAILURE); } else if (pid > 0) {  assert(pid != 0);   int status;  waitpid(pid, &status, 0); free(command); return status; } return COMMAND_EXECUTION_FAILED;}int handle_input_redirection(const Command* cmd, const char* cwd_path){ assert(command_is_valid(cmd)); assert(cwd_path != NULL); assert(is_valid_path(cwd_path)); if(NULL == cmd || NULL == cwd_path) return INVALID_ARGUMENTS; if(!command_is_valid(cmd) || !is_valid_path(cwd_path)) return INVALID_ARGUMENTS;  for(int i=0; i<cmd->argc; i++){  if(strcmp(command_get_arg(cmd,i),"<") == 0){   if(cmd->argc < 3){ printf("ERROR: Not enough arguments for redirection, Minimum 3 arguments required\n"); return REDIRECTION_FAILED; } if(i+1 >= cmd->argc){  printf("ERROR: Last argument should be a filename not the redirection operator\n"); return REDIRECTION_FAILED; }  const char* arg_i_plus_one = command_get_arg(cmd,i+1); assert(arg_i_plus_one != NULL); char* filename = strdup(arg_i_plus_one);  assert(NULL != filename); char* filepath = strdup(cwd_path);  assert(NULL != filepath); if(NULL == filename || NULL == filepath){ printf("ERROR: error in finding file from the arguments of the command "); command_print(cmd); free(filename); free(filepath); return REDIRECTION_FAILED; }  if(filepath[strlen(filepath)-1] != '/'){ strcat(filepath,"/");  } strcat(filepath,filename);  assert(is_valid_path(filepath));  int input_fd = nqp_open(filepath); if(input_fd < 0){ printf("Redirection Error: nqp_open input file {%s} not found\n", command_get_arg(cmd,i+1)); return REDIRECTION_FAILED; } assert(input_fd >= 0);  int mem_fd = memfd_create(filepath, 0); if (mem_fd < 0) { printf("ERROR: memfd_create can't create input_redirect"); nqp_close(input_fd);  return REDIRECTION_FAILED; } assert(mem_fd >= 0);  char buffer[READ_BUFFER_SIZE] = {0}; ssize_t bytes_read = 0; while ((bytes_read = nqp_read(input_fd, buffer, sizeof(buffer))) > 0) { write(mem_fd, &buffer, bytes_read);  memset(buffer, 0, READ_BUFFER_SIZE);  } nqp_close(input_fd);  lseek(mem_fd, 0, SEEK_SET);  printf("handle_input_redirection: memfd = {%d}\n", mem_fd); return mem_fd;  } }  return STDIN_FILENO;}int main( int argc, char *argv[], char *envp[] ){ char line_buffer[MAX_LINE_SIZE] = {0}; char *volume_label = NULL; nqp_error mount_error; if ( argc != 2 ){ fprintf( stderr, "Usage: ./nqp_shell volume.img\n" ); exit( EXIT_FAILURE ); } mount_error = nqp_mount( argv[1], NQP_FS_EXFAT ); if ( mount_error != NQP_OK ){ if ( mount_error == NQP_FSCK_FAIL ){ fprintf( stderr, "%s is inconsistent, not mounting.\n", argv[1] ); } exit( EXIT_FAILURE ); } volume_label = nqp_vol_label( ); printf( "%s:\\> ", volume_label );     Curr_Dir* cwd = construct_empty_curr_dir(); while (true){ char mssg[MAX_LINE_SIZE] = {0}; snprintf(mssg, MAX_LINE_SIZE, "%s:\\> ",volume_label); char* line = readline(mssg); strncpy(line_buffer, line, MAX_LINE_SIZE); if (line == NULL) {  printf("\n"); break; }  add_history(line_buffer);  Command* new_command = command_create(line_buffer); assert(NULL != new_command); if(NULL == new_command) return EXIT_FAILURE; if(!command_is_valid(new_command)){  command_destroy(new_command); continue;  }  const int num_pipes = calc_num_pipes_marker(new_command); if(num_pipes > 0){   Pipe_Commands* pipe_cmds = create_Pipe_Commands(num_pipes,line_buffer); assert(pipe_commands_is_valid(pipe_cmds)); if(NULL == pipe_cmds) continue;  int return_code = execute_pipes(pipe_cmds,cwd,envp,STDOUT_FILENO); printf("Pipes return code: %d",return_code); command_destroy(new_command); continue;  } if(num_pipes == INVALID_USECASE){ printf("pipe operator not used properly\n"); command_destroy(new_command); continue; }  if(!execute_command(new_command, cwd, envp) && 0 == num_pipes){ assert(false); printf("Failure to execute the command:\n"); command_print(new_command); command_destroy(new_command); continue; }  memset(line_buffer,0,MAX_LINE_SIZE); }  assert(NULL != cwd); if(NULL != cwd){ destroy_curr_dir(cwd); } return EXIT_SUCCESS;}